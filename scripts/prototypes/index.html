<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  margin: 0;
}

#vis {
    margin: 0 auto;
    max-width: 960px;
    width: 100%;
}

#vis div {
    float: left;
    position: relative;
}

.small-map {
  opacity: 0.6;
}

rect.textbox {
  opacity: 0;
}

.small-map-wrapper:hover .small-map.hover {
  opacity: 0.8;
}

.small-map-wrapper:hover rect.hover {
  opacity: 0.3; 
}

svg.active {
  opacity: 1;
}

rect.active {
  opacity: 1;
  fill: #333;
}

text.active {
  fill: white;
}

path {
  fill: none;
  stroke-linejoin: round;
}

div#tooltip { 
  position: absolute;
  box-sizing: border-box;
  padding: 8px; 
  border-radius: 2px;    
  background: #000;
  opacity: 0.8;
  font: bold 8px sans-serif;    
  text-align: center;       
  color: #fff;
}

div#tooltip:after {
  content: "\25BC";
  font: 10px;
  display: inline;
  line-height: 1;
  position: absolute;
  top: 100%;
  left: 0;
  width: 100%;
  margin: -2px 0 0 0;
  color: #000;
}

.axis path{
  stroke: none;
}
</style>
<div id="vis"></div>
<div id="test"></div>
<script src="//d3js.org/d3.v4.min.js"></script>
<script src="//d3js.org/d3-tile.v0.0.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script>
var busstops_eb = [];

var pi = Math.PI,
    tau = 2 * pi;

var width = Math.min(150, window.innerWidth),
    height = Math.min(75, window.innerHeight);

var color = d3.scaleSequential(d3.interpolateMagma);

// Initialize the projection to fit the world in a 1Ã—1 square centered at the origin.
var projection = d3.geoMercator()
    .scale(1 / tau)
    .translate([0, 0]);

var path = d3.geoPath()
    .projection(projection);

var fullViz = d3.select("#vis");

var legendWidth = 100;

var legendY = d3.scaleLinear()
    .domain([0, legendWidth]);

var inverseLegendY = d3.scaleLinear()
    .range([0, legendWidth]);

var tooltip = d3.select("body")
    .append("div")
    .attr("id", "tooltip")
    .style("visibility", "hidden");

d3.queue()
    .defer(d3.json, "73_wb.topojson")
    .defer(d3.json, "data_wb.json")
    .await(ready);

function ready(error, rtEB, bunchingEB) {
  if (error) throw error;

	var bbox = path.bounds(topojson.feature(rtEB, rtEB.objects.stops)),

  bunchingEB = bunchingEB.filter(b => b.terminal != "wait|4040");

  maxBunching = d3.max(bunchingEB, b => d3.max(Object.values(b.values).map(v => v.proportion)));
  color.domain([0, maxBunching]);

  bunchingEB.forEach((data, i) => {
    var wrapper = fullViz
        .append("div")
        .attr("width", width + "px")
        .attr("height", height + "px");

    drawSmallMultiples(wrapper, data, i);
  });

  fullWidth = width * bunchingEB.length
  fullHeight = height * 4
  var bigWrapper = fullViz
      .append("div")
      .attr("width", fullWidth)
      .attr("height", fullHeight);

  drawLargeMap(bigWrapper, bunchingEB[0], fullWidth, fullHeight);

  function drawSmallMultiples(wrapper, data, i) {
    var svg = wrapper.append("svg")
        .attr("class", "small-map-wrapper")
        .attr("width", width)
        .attr("height", height + 20)

    var map = svg.append("svg")
        .attr("class", "small-map hover")
        .attr("width", width)
        .attr("height", height)
        .on("click", function(d) {
          if (!d3.select(this).classed("active")) {
            d3.selectAll(".active").classed("active", false).classed("hover", true);
            d3.select(this).classed("hover", false).classed("active", true);
            d3.selectAll(".textbox"+i).classed("hover", false).classed("active", true);
            updateColor(bunchingEB.filter(b => b.time_of_day == data.time_of_day)[0]);
          }
        });

    drawMap(bbox, width, height, map);

    var route = drawRoute(svg, data, rtEB);
    route.attr("stroke-width", 2)

    var rectLayer = svg.append("g");
    var textLayer = svg.append("g");

    var text = textLayer.append("text")
        .attr("class", "textbox" + i)
        .attr("text-anchor", "middle")
        .attr("x", width / 2)
        .attr("y", height + 15)
        .attr("font-family", "sans-serif")
        .attr("font-weight", "bold")
        .attr("font-size", "12px")
        .text(data.time_of_day);

    var textBBox = text.node().getBBox();

    var rect = rectLayer.append("rect")
        .attr("class", "hover textbox textbox" + i)
        .attr("rx", 3)
        .attr("ry", 3)
        .attr("x", textBBox.x - 2)
        .attr("y", textBBox.y - 1)
        .attr("width", textBBox.width + 4)
        .attr("height", textBBox.height + 2)
        .attr("fill", "#bbb");

    if (i == 0) {
      map.classed("active", true).classed("hover", false)
      rect.classed("active", true).classed("hover", false)
      text.classed("active", true).classed("hover", false)
    }
  }

  function drawLargeMap(wrapper, data, width, height) {
    var svg = wrapper.append("svg")
        .attr("id", "fullmap")
        .attr("width", width)
        .attr("height", height);

    drawMap(bbox, width, height, svg);

    var route = drawRoute(svg, data, rtEB);

    route.attr("class", "big-map-path")
        .attr("stroke-width", 5)
        .on("mouseover", function (d) {
          d3.select(this).attr("stroke-width", 7);
          tooltip.style("visibility", "visible")
              .html(d.properties.stpnm + "<br />" + data.values[d.properties.stpid].count + " incidents, " + d3.format(".0%")(data.values[d.properties.stpid].proportion) + " of trips");

          var tip = document.getElementById("tooltip")
          var tipw = tip.offsetWidth
          var tiph = tip.offsetHeight

          var bbox = this.getBBox();
          var matrix = this.getScreenCTM();
          var svg = document.getElementById("fullmap");
          var pt = svg.createSVGPoint();
          pt.x = bbox.x  + window.scrollX + (bbox.width / 2) - (tipw / 2);
          pt.y = bbox.y - tiph + window.scrollY;
          var trans = pt.matrixTransform(matrix);

          tooltip
              .style("left", (trans.x) + "px")   
              .style("top", (trans.y - 10) +  "px")
        })
        .on("mouseout", function (d) {
          d3.select(this).attr("stroke-width", 5);
          tooltip.style("visibility", "hidden");
        })

    var legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", "translate(20," + (height - 50) + ")");

    inverseLegendY.domain(color.domain());
    legendY.range(color.domain());

    var legendAxisArea = legend.append("g")
        .attr("class", "axis axis--y")
        .attr("transform", "translate(0,15)")

    var legendAxis = d3.axisBottom()
      .scale(inverseLegendY)
      .tickValues([0, maxBunching / 2, maxBunching])
      .tickSize(3)
      .tickFormat(d3.format(".0%"))

    legendAxisArea.call(legendAxis);

    legend.selectAll(".bands")
        .data(d3.range(legendWidth), d => d)
      .enter().append("rect")
        .attr("x", d => d)
        .attr("y", 10)
        .attr("width", 1)
        .attr("height", 5)
        .attr("fill", d => color(legendY(d)));
  }
}

function drawMap(b, width, height, svg) {
  var s = 0.95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height),
      t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];

  var tiles = d3.tile()
      .size([width, height])
      .scale(s)
      .translate([t[0], t[1]])
      ();

  projection
      .scale(s / tau)
      .translate([t[0], t[1]]);

  var map = svg.append("g")
    .selectAll("image").data(tiles).enter().append("image")
      .attr("xlink:href", d => "http://" + "abc"[d[1] % 3] + ".basemaps.cartocdn.com/light_all/" + d[2] + "/" + d[0] + "/" + d[1] + ".png")
      .attr("x", d => (d[0] + tiles.translate[0]) * tiles.scale)
      .attr("y", d => (d[1] + tiles.translate[1]) * tiles.scale)
      .attr("width", tiles.scale)
      .attr("height", tiles.scale);

  return map;
}

function drawRoute(svg, data, rtEB) {
  var route = svg.selectAll(".stops")
      .data(topojson.feature(rtEB, rtEB.objects.stops).features)
    .enter().append("path")
      .attr("d", path)
      .attr("fill", "none")
      .attr("stroke", d => color(data.values[d.properties.stpid].proportion))
      .attr("pointer-events", "visibleStroke");

  return route;
}

function updateColor(data) {
  d3.selectAll(".big-map-path")
      .attr("stroke", d => color(data.values[d.properties.stpid].proportion));
}
</script>